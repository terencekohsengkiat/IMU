<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WitMotion Commercial Dashboard</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { background-color: #1a202c; color: #e2e8f0; }
        .card { background-color: #2d3748; border-radius: 0.5rem; padding: 1.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .btn { transition: all 0.2s; }
        .btn:active { transform: scale(0.95); }
    </style>
</head>
<body class="min-h-screen p-6">

    <header class="flex justify-between items-center mb-8">
        <div>
            <h1 class="text-3xl font-bold text-white">WitMotion <span class="text-blue-500">Pro</span> Dashboard</h1>
            <p class="text-gray-400 text-sm mt-1">Multi-Sensor Visualization & Analytics</p>
        </div>
        <div class="flex gap-4">
            <button id="addDeviceBtn" class="btn bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg font-semibold shadow-lg flex items-center">
                <span class="text-xl mr-2">+</span> Add Sensor
            </button>
            <button id="recordBtn" class="btn bg-red-600 hover:bg-red-700 text-white px-6 py-2 rounded-lg font-semibold shadow-lg hidden">
                Start Recording
            </button>
            <button id="exportBtn" class="btn bg-green-600 hover:bg-green-700 text-white px-6 py-2 rounded-lg font-semibold shadow-lg hidden">
                Export CSV
            </button>
        </div>
    </header>

    <div id="deviceContainer" class="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6">
        </div>

    <template id="deviceTemplate">
        <div class="device-card card relative">
            <div class="flex justify-between items-start mb-4 border-b border-gray-600 pb-2">
                <div>
                    <h2 class="text-xl font-bold text-white device-name" contenteditable="true" title="Click to rename">WT901BLE67</h2>
                    <span class="text-xs text-gray-400 device-id">ID: 00:00:00...</span>
                </div>
                <div class="flex gap-2">
                    <button class="settings-btn text-gray-400 hover:text-white" title="Settings">⚙️</button>
                    <button class="calibrate-btn text-gray-400 hover:text-yellow-400" title="Calibrate">⚖️</button>
                    <button class="disconnect-btn text-gray-400 hover:text-red-500" title="Disconnect">✕</button>
                </div>
            </div>

            <div class="canvas-container h-64 bg-gray-900 rounded-lg mb-4 relative overflow-hidden border border-gray-700">
                </div>

            <div class="grid grid-cols-3 gap-2 text-center text-sm font-mono mb-4">
                <div class="bg-gray-700 p-2 rounded">
                    <div class="text-gray-400 text-xs">Angle X</div>
                    <div class="text-blue-400 font-bold val-ang-x">0.00°</div>
                </div>
                <div class="bg-gray-700 p-2 rounded">
                    <div class="text-gray-400 text-xs">Angle Y</div>
                    <div class="text-blue-400 font-bold val-ang-y">0.00°</div>
                </div>
                <div class="bg-gray-700 p-2 rounded">
                    <div class="text-gray-400 text-xs">Angle Z</div>
                    <div class="text-blue-400 font-bold val-ang-z">0.00°</div>
                </div>
            </div>

            <div class="h-40 relative w-full">
                <canvas class="device-chart"></canvas>
            </div>

            <div class="settings-modal absolute inset-0 bg-gray-800/95 z-50 rounded-lg p-6 hidden flex-col justify-center">
                <h3 class="text-lg font-bold mb-4">Sensor Configuration</h3>
                
                <label class="block text-sm mb-2">Return Rate</label>
                <select class="rate-select w-full bg-gray-700 rounded p-2 mb-4">
                    <option value="06">10Hz (Default)</option>
                    <option value="07">20Hz</option>
                    <option value="08">50Hz</option>
                    <option value="09">100Hz</option>
                    <option value="0B">200Hz</option>
                </select>

                <label class="block text-sm mb-2">Bandwidth</label>
                <select class="bw-select w-full bg-gray-700 rounded p-2 mb-6">
                    <option value="04">20Hz (Default)</option>
                    <option value="01">188Hz</option>
                    <option value="00">256Hz</option>
                </select>

                <div class="flex justify-end gap-3">
                    <button class="close-settings btn bg-gray-600 px-4 py-1 rounded">Close</button>
                    <button class="save-settings btn bg-blue-600 px-4 py-1 rounded">Apply</button>
                </div>
            </div>
        </div>
    </template>

    <script>
        // --- CONSTANTS ---
        const SERVICE_UUID = "0000ffe5-0000-1000-8000-00805f9a34fb";
        const READ_UUID = "0000ffe4-0000-1000-8000-00805f9a34fb";
        const WRITE_UUID = "0000ffe9-0000-1000-8000-00805f9a34fb";

        // Import OrbitControls
        import("https://cdn.jsdelivr.net/npm/three@0.128.0/examples/jsm/controls/OrbitControls.js")
            .then(module => { window.OrbitControls = module.OrbitControls; });

        // Global State
        const devices = new Map(); 
        let isRecording = false;
        let recordingStartTime = 0;

        // --- 1. MULTI-CONNECTION HANDLER ---
        document.getElementById('addDeviceBtn').addEventListener('click', async () => {
            try {
                const device = await navigator.bluetooth.requestDevice({
                    filters: [{ namePrefix: 'WT' }],
                    optionalServices: [SERVICE_UUID]
                });

                if (devices.has(device.id)) {
                    alert("Device already connected!");
                    return;
                }

                const server = await device.gatt.connect();
                const service = await server.getPrimaryService(SERVICE_UUID);
                const readChar = await service.getCharacteristic(READ_UUID);
                const writeChar = await service.getCharacteristic(WRITE_UUID);

                const ui = createDeviceUI(device);
                
                const deviceContext = {
                    device, server, writeChar, ui,
                    dataLog: [],
                    lastData: {}
                };
                devices.set(device.id, deviceContext);

                await readChar.startNotifications();
                readChar.addEventListener('characteristicvaluechanged', (e) => handleData(e, device.id));

                document.getElementById('recordBtn').classList.remove('hidden');

            } catch (err) {
                console.error("Connection failed", err);
            }
        });

        // --- 2. CREATE UI CARD ---
        function createDeviceUI(device) {
            const template = document.getElementById('deviceTemplate');
            const clone = template.content.cloneNode(true);
            const card = clone.querySelector('.device-card');
            const container = document.getElementById('deviceContainer');

            card.dataset.id = device.id;
            clone.querySelector('.device-name').innerText = device.name || "Unknown Sensor";
            clone.querySelector('.device-id').innerText = device.id;

            // --- INJECT ALIGNMENT CONTROLS ---
            const settingsBody = clone.querySelector('.settings-modal');
            const rotationControls = document.createElement('div');
            rotationControls.innerHTML = `
                <h4 class="text-sm font-bold text-gray-400 mt-4 mb-2">3D Model Alignment</h4>
                <div class="grid grid-cols-1 gap-2 mb-4">
                    <label class="text-xs">Rotation X: <span class="val-rot-x">0</span>°</label>
                    <input type="range" class="slider-rot-x w-full" min="0" max="360" value="0">
                    <label class="text-xs">Rotation Y: <span class="val-rot-y">0</span>°</label>
                    <input type="range" class="slider-rot-y w-full" min="0" max="360" value="0">
                    <label class="text-xs">Rotation Z: <span class="val-rot-z">0</span>°</label>
                    <input type="range" class="slider-rot-z w-full" min="0" max="360" value="0">
                </div>
            `;
            settingsBody.insertBefore(rotationControls, settingsBody.lastElementChild);

            container.appendChild(clone);
            const liveCard = container.querySelector(`.device-card[data-id="${device.id}"]`);

            // --- 3D SCENE SETUP ---
            const canvasContainer = liveCard.querySelector('.canvas-container');
            const scene = new THREE.Scene();
            scene.background = new THREE.Color(0x111827);

            const camera = new THREE.PerspectiveCamera(50, canvasContainer.offsetWidth / canvasContainer.offsetHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(canvasContainer.offsetWidth, 256);
            canvasContainer.appendChild(renderer.domElement);

            // Auto-Resizer
            const resizeObserver = new ResizeObserver(() => {
                const width = canvasContainer.clientWidth;
                const height = canvasContainer.clientHeight;
                if (width > 0 && height > 0) {
                    renderer.setSize(width, height, false);
                    camera.aspect = width / height;
                    camera.updateProjectionMatrix();
                }
            });
            resizeObserver.observe(canvasContainer);

            // Visual Helpers
            const axesHelper = new THREE.AxesHelper(3);
            scene.add(axesHelper);

            // Lighting
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 1);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            // --- DATA GROUP (Rotated by Sensor using Quaternions) ---
            const dataGroup = new THREE.Group();
            
            // Initialize Quaternions for smoothing
            dataGroup.userData = { 
                currentQuat: new THREE.Quaternion(),
                targetQuat: new THREE.Quaternion()
            };
            scene.add(dataGroup);

            // --- ALIGNMENT GROUP (Rotated by User Sliders) ---
            const alignmentGroup = new THREE.Group();
            dataGroup.add(alignmentGroup);

            camera.position.set(3, 2, 5); 
            camera.lookAt(0, 0, 0);

            // Load Model
            const loader = new THREE.OBJLoader();
            loader.load(
                'assets/sensor.obj', 
                function (object) {
                    console.log("Model Loaded for " + device.name);
                    const box = new THREE.Box3().setFromObject(object);
                    const size = new THREE.Vector3();
                    box.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scaleFactor = 3 / maxDim; 
                    object.scale.set(scaleFactor, scaleFactor, scaleFactor);

                    const center = box.getCenter(new THREE.Vector3());
                    object.position.sub(center);

                    object.traverse((child) => {
                        if (child.isMesh) child.material = new THREE.MeshPhongMaterial({ color: 0x3b82f6 });
                    });

                    alignmentGroup.add(object);
                },
                undefined,
                function (error) {
                    console.warn("Model failed, using cube.");
                    const geo = new THREE.BoxGeometry(1.5, 0.5, 2);
                    const mat = new THREE.MeshPhongMaterial({ color: 0xff4444 });
                    const cube = new THREE.Mesh(geo, mat);
                    alignmentGroup.add(cube);
                }
            );

            // --- SMOOTH ANIMATION LOOP (QUATERNION SLERP) ---
            function animate() {
                requestAnimationFrame(animate);
                
                // Slerp (Spherical Linear Interpolation) handles the 180-> -180 jump correctly
                const smoothing = 0.15; 
                
                if (dataGroup.userData.targetQuat) {
                    dataGroup.userData.currentQuat.slerp(dataGroup.userData.targetQuat, smoothing);
                    dataGroup.quaternion.copy(dataGroup.userData.currentQuat);
                }

                renderer.render(scene, camera);
            }
            animate();

            // --- CHART ---
            const ctx = liveCard.querySelector('.device-chart').getContext('2d');
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array(50).fill(''),
                    datasets: [
                        { label: 'Pitch (X)', data: Array(50).fill(0), borderColor: '#ef4444', borderWidth: 2, pointRadius: 0 },
                        { label: 'Roll (Y)', data: Array(50).fill(0), borderColor: '#22c55e', borderWidth: 2, pointRadius: 0 },
                        { label: 'Yaw (Z)', data: Array(50).fill(0), borderColor: '#3b82f6', borderWidth: 2, pointRadius: 0 }
                    ]
                },
                options: { 
                    animation: false, 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    scales: { y: { display: true, grid: { color: '#4b5563' } }, x: { display: false } },
                    plugins: { legend: { display: true, labels: { color: 'white' } } }
                }
            });

            // --- UI BINDINGS ---
            liveCard.querySelector('.settings-btn').addEventListener('click', () => {
                liveCard.querySelector('.settings-modal').classList.remove('hidden');
                liveCard.querySelector('.settings-modal').classList.add('flex');
            });
            liveCard.querySelector('.close-settings').addEventListener('click', () => {
                liveCard.querySelector('.settings-modal').classList.add('hidden');
                liveCard.querySelector('.settings-modal').classList.remove('flex');
            });
            liveCard.querySelector('.save-settings').addEventListener('click', () => {
                const rate = liveCard.querySelector('.rate-select').value;
                const bw = liveCard.querySelector('.bw-select').value;
                applySettings(device.id, rate, bw);
                liveCard.querySelector('.settings-modal').classList.add('hidden');
                liveCard.querySelector('.settings-modal').classList.remove('flex');
            });
            liveCard.querySelector('.calibrate-btn').addEventListener('click', () => calibrateSensor(device.id));

            // Alignment Sliders
            const updateAlignment = () => {
                const rx = liveCard.querySelector('.slider-rot-x').value;
                const ry = liveCard.querySelector('.slider-rot-y').value;
                const rz = liveCard.querySelector('.slider-rot-z').value;
                
                liveCard.querySelector('.val-rot-x').innerText = rx;
                liveCard.querySelector('.val-rot-y').innerText = ry;
                liveCard.querySelector('.val-rot-z').innerText = rz;

                alignmentGroup.rotation.x = rx * (Math.PI / 180);
                alignmentGroup.rotation.y = ry * (Math.PI / 180);
                alignmentGroup.rotation.z = rz * (Math.PI / 180);
            };
            liveCard.querySelector('.slider-rot-x').addEventListener('input', updateAlignment);
            liveCard.querySelector('.slider-rot-y').addEventListener('input', updateAlignment);
            liveCard.querySelector('.slider-rot-z').addEventListener('input', updateAlignment);

            return { scene, camera, renderer, mesh: dataGroup, chart, card: liveCard };
        }

        // --- 3. DATA PARSING (QUATERNION FIX) ---
        function handleData(event, deviceId) {
            const value = event.target.value;
            const context = devices.get(deviceId);
            if (!context) return;

            if (value.getUint8(0) === 0x55 && value.getUint8(1) === 0x61) {
                
                const getShort = (idx) => {
                    let v = (value.getUint8(idx+1) << 8) | value.getUint8(idx);
                    return v >= 32768 ? v - 65536 : v;
                };

                const ax = getShort(2) / 32768 * 16;
                const ay = getShort(4) / 32768 * 16;
                const az = getShort(6) / 32768 * 16;
                
                const angX = getShort(14) / 32768 * 180; // Sensor X
                const angY = getShort(16) / 32768 * 180; // Sensor Y
                const angZ = getShort(18) / 32768 * 180; // Sensor Z

                // --- TEXT DISPLAY (0-360 Compass) ---
                let compassHeading = (angZ < 0) ? (angZ + 360) : angZ;

                const ui = context.ui;
                ui.card.querySelector('.val-ang-x').innerText = angX.toFixed(2) + "°";
                ui.card.querySelector('.val-ang-y').innerText = angY.toFixed(2) + "°";
                ui.card.querySelector('.val-ang-z').innerText = compassHeading.toFixed(2) + "°";

                // --- 3D ROTATION MAPPING (YOUR REQUEST) ---
                // Sensor X -> Pitch (3D X)
                // Sensor Y -> Roll (3D Z)
                // Sensor Z -> Yaw (3D Y)
                
                if (ui.mesh && ui.mesh.userData.targetQuat) {
                    // Convert Degrees to Radians
                    const pitch = angX * (Math.PI / 180);
                    const roll = -angY * (Math.PI / 180); 
                    const yaw = angZ * (Math.PI / 180); // Negative to match standard compass rotation (Right = Clockwise)

                    // Create Euler with specific order to prevent gimbal lock artifacts
                    // YXZ is often better for Yaw-based rotations
                    const euler = new THREE.Euler(pitch, yaw, roll, 'YXZ'); 
                    
                    // Update Target Quaternion
                    ui.mesh.userData.targetQuat.setFromEuler(euler);
                }

                // Update Chart
                const chart = ui.chart;
                chart.data.datasets[0].data.push(angX);
                chart.data.datasets[1].data.push(angY);
                chart.data.datasets[2].data.push(compassHeading); 
                chart.data.datasets[0].data.shift();
                chart.data.datasets[1].data.shift();
                chart.data.datasets[2].data.shift();
                chart.update();

                // Recording
                if (isRecording) {
                    const timestamp = Date.now() - recordingStartTime;
                    context.dataLog.push({ timestamp, ax, ay, az, angX, angY, angZ: compassHeading });
                }
            }
        }

        // --- 4. COMMANDS ---
        async function sendCommand(deviceId, commandBytes) {
            const context = devices.get(deviceId);
            if (!context) return;
            try {
                await context.writeChar.writeValue(new Uint8Array([0xFF, 0xAA, 0x69, 0x88, 0xB5])); 
                await new Promise(r => setTimeout(r, 20));
                await context.writeChar.writeValue(new Uint8Array(commandBytes));
                await new Promise(r => setTimeout(r, 20));
                await context.writeChar.writeValue(new Uint8Array([0xFF, 0xAA, 0x00, 0x00, 0x00])); 
            } catch (e) {
                console.error("Command failed", e);
            }
        }

        function applySettings(deviceId, rateHex, bwHex) {
            sendCommand(deviceId, [0xFF, 0xAA, 0x03, parseInt(rateHex, 16), 0x00]);
            setTimeout(() => {
                sendCommand(deviceId, [0xFF, 0xAA, 0x1F, parseInt(bwHex, 16), 0x00]);
            }, 100);
        }

        function calibrateSensor(deviceId) {
            if(confirm("Keep sensor flat and still. Start Acceleration Calibration?")) {
                sendCommand(deviceId, [0xFF, 0xAA, 0x01, 0x01, 0x00]);
            }
        }

        // --- 5. RECORDING & EXPORT ---
        document.getElementById('recordBtn').addEventListener('click', () => {
            isRecording = !isRecording;
            const btn = document.getElementById('recordBtn');
            if (isRecording) {
                recordingStartTime = Date.now();
                btn.innerText = "Stop Recording";
                btn.classList.replace('bg-red-600', 'bg-gray-600');
                devices.forEach(d => d.dataLog = []);
            } else {
                btn.innerText = "Start Recording";
                btn.classList.replace('bg-gray-600', 'bg-red-600');
                document.getElementById('exportBtn').classList.remove('hidden');
            }
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
            devices.forEach((context, id) => {
                let csv = "Timestamp,AccX,AccY,AccZ,AngleX,AngleY,AngleZ\n";
                context.dataLog.forEach(row => {
                    csv += `${row.timestamp},${row.ax},${row.ay},${row.az},${row.angX},${row.angY},${row.angZ}\n`;
                });
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `Sensor_${id}_Data.csv`;
                a.click();
            });
        });
    </script>
</body>
</html>
