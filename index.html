<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WitMotion Commercial Dashboard</title>
    
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/loaders/OBJLoader.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    
    <script src="https://cdn.tailwindcss.com"></script>
    
    <style>
        body { background-color: #1a202c; color: #e2e8f0; }
        .card { background-color: #2d3748; border-radius: 0.5rem; padding: 1.5rem; box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1); }
        .btn { transition: all 0.2s; }
        .btn:active { transform: scale(0.95); }
    </style>
</head>
<body class="min-h-screen p-6">

    <header class="flex justify-between items-center mb-8">
        <div>
            <h1 class="text-3xl font-bold text-white">WitMotion <span class="text-blue-500">Pro</span> Dashboard</h1>
            <p class="text-gray-400 text-sm mt-1">Multi-Sensor Visualization & Analytics</p>
        </div>
        <div class="flex gap-4">
            <button id="addDeviceBtn" class="btn bg-blue-600 hover:bg-blue-700 text-white px-6 py-2 rounded-lg font-semibold shadow-lg flex items-center">
                <span class="text-xl mr-2">+</span> Add Sensor
            </button>
            <button id="recordBtn" class="btn bg-red-600 hover:bg-red-700 text-white px-6 py-2 rounded-lg font-semibold shadow-lg hidden">
                Start Recording
            </button>
            <button id="exportBtn" class="btn bg-green-600 hover:bg-green-700 text-white px-6 py-2 rounded-lg font-semibold shadow-lg hidden">
                Export CSV
            </button>
        </div>
    </header>

    <div id="deviceContainer" class="grid grid-cols-1 lg:grid-cols-2 xl:grid-cols-3 gap-6">
        </div>

    <template id="deviceTemplate">
        <div class="device-card card relative">
            <div class="flex justify-between items-start mb-4 border-b border-gray-600 pb-2">
                <div>
                    <h2 class="text-xl font-bold text-white device-name" contenteditable="true" title="Click to rename">WT901BLE67</h2>
                    <span class="text-xs text-gray-400 device-id">ID: 00:00:00...</span>
                </div>
                <div class="flex gap-2">
                    <button class="settings-btn text-gray-400 hover:text-white" title="Settings">⚙️</button>
                    <button class="calibrate-btn text-gray-400 hover:text-yellow-400" title="Calibrate">⚖️</button>
                    <button class="disconnect-btn text-gray-400 hover:text-red-500" title="Disconnect">✕</button>
                </div>
            </div>

            <div class="canvas-container h-64 bg-gray-900 rounded-lg mb-4 relative overflow-hidden border border-gray-700">
                </div>

            <div class="grid grid-cols-3 gap-2 text-center text-sm font-mono mb-4">
                <div class="bg-gray-700 p-2 rounded">
                    <div class="text-gray-400 text-xs">Angle X</div>
                    <div class="text-blue-400 font-bold val-ang-x">0.00°</div>
                </div>
                <div class="bg-gray-700 p-2 rounded">
                    <div class="text-gray-400 text-xs">Angle Y</div>
                    <div class="text-blue-400 font-bold val-ang-y">0.00°</div>
                </div>
                <div class="bg-gray-700 p-2 rounded">
                    <div class="text-gray-400 text-xs">Angle Z</div>
                    <div class="text-blue-400 font-bold val-ang-z">0.00°</div>
                </div>
            </div>

            <div class="h-40">
                <canvas class="device-chart"></canvas>
            </div>

            <div class="settings-modal absolute inset-0 bg-gray-800/95 z-50 rounded-lg p-6 hidden flex-col justify-center">
                <h3 class="text-lg font-bold mb-4">Sensor Configuration</h3>
                
                <label class="block text-sm mb-2">Return Rate</label>
                <select class="rate-select w-full bg-gray-700 rounded p-2 mb-4">
                    <option value="06">10Hz (Default)</option>
                    <option value="07">20Hz</option>
                    <option value="08">50Hz</option>
                    <option value="09">100Hz</option>
                    <option value="0B">200Hz</option>
                </select>

                <label class="block text-sm mb-2">Bandwidth</label>
                <select class="bw-select w-full bg-gray-700 rounded p-2 mb-6">
                    <option value="04">20Hz (Default)</option>
                    <option value="01">188Hz</option>
                    <option value="00">256Hz</option>
                </select>

                <div class="flex justify-end gap-3">
                    <button class="close-settings btn bg-gray-600 px-4 py-1 rounded">Close</button>
                    <button class="save-settings btn bg-blue-600 px-4 py-1 rounded">Apply</button>
                </div>
            </div>
        </div>
    </template>

    <script>
        // --- CONSTANTS ---
        const SERVICE_UUID = "0000ffe5-0000-1000-8000-00805f9a34fb";
        const READ_UUID = "0000ffe4-0000-1000-8000-00805f9a34fb";
        const WRITE_UUID = "0000ffe9-0000-1000-8000-00805f9a34fb";

        // Global State
        const devices = new Map(); // Store connected device objects
        let isRecording = false;
        let recordingStartTime = 0;

        // --- 1. MULTI-CONNECTION HANDLER ---
        document.getElementById('addDeviceBtn').addEventListener('click', async () => {
            try {
                const device = await navigator.bluetooth.requestDevice({
                    // Option A: Specific filter (Try this if Option B fails)
                    // filters: [{ namePrefix: 'WT' }], 
                    
                    // Option B: Accept ALL devices (Best for troubleshooting)
                    acceptAllDevices: true,
                    optionalServices: [SERVICE_UUID]
                });

                if (devices.has(device.id)) {
                    alert("Device already connected!");
                    return;
                }

                const server = await device.gatt.connect();
                const service = await server.getPrimaryService(SERVICE_UUID);
                const readChar = await service.getCharacteristic(READ_UUID);
                const writeChar = await service.getCharacteristic(WRITE_UUID);

                // Create UI for this device
                const ui = createDeviceUI(device);
                
                // Store device context
                const deviceContext = {
                    device, server, writeChar, ui,
                    dataLog: [],
                    lastData: {}
                };
                devices.set(device.id, deviceContext);

                // Start Data Stream
                await readChar.startNotifications();
                readChar.addEventListener('characteristicvaluechanged', (e) => handleData(e, device.id));

                // Show Global Controls
                document.getElementById('recordBtn').classList.remove('hidden');

            } catch (err) {
                console.error("Connection failed", err);
            }
        });

        // --- 2. CREATE UI CARD (UPDATED FOR 3D MODEL) ---
        function createDeviceUI(device) {
            const template = document.getElementById('deviceTemplate');
            const clone = template.content.cloneNode(true);
            const card = clone.querySelector('.device-card');
            const container = document.getElementById('deviceContainer');

            // Set ID and Name
            card.dataset.id = device.id;
            clone.querySelector('.device-name').innerText = device.name || "Unknown Sensor";
            clone.querySelector('.device-id').innerText = device.id;

            // Setup 3D Scene
            const canvasContainer = clone.querySelector('.canvas-container');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, canvasContainer.offsetWidth / canvasContainer.offsetHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
            renderer.setSize(canvasContainer.offsetWidth, 256);
            canvasContainer.appendChild(renderer.domElement);

            // --- LIGHTING (Required for imported models) ---
            const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
            scene.add(ambientLight);
            const dirLight = new THREE.DirectionalLight(0xffffff, 0.8);
            dirLight.position.set(5, 10, 7);
            scene.add(dirLight);

            // --- PIVOT GROUP ---
            // We rotate this 'pivot' group instead of the model directly.
            // This allows us to swap the model (cube -> obj) without breaking the rotation logic.
            const pivot = new THREE.Group();
            scene.add(pivot);
            camera.position.z = 5;

            // 1. Add Placeholder Cube (Instant visual feedback)
            const geometry = new THREE.BoxGeometry(1.5, 0.5, 2);
            const material = new THREE.MeshNormalMaterial();
            const placeholder = new THREE.Mesh(geometry, material);
            pivot.add(placeholder);

            // 2. Load .OBJ File (Asynchronous)
            const loader = new THREE.OBJLoader();
            loader.load(
                'assets/sensor.obj', // Make sure your file in GitHub is named exactly this
                function (object) {
                    // Remove placeholder
                    pivot.remove(placeholder);
                    
                    // Normalize Scale (Commercial grade polish)
                    // This ensures massive or tiny models fit nicely in the view
                    const box = new THREE.Box3().setFromObject(object);
                    const size = new THREE.Vector3();
                    box.getSize(size);
                    const maxDim = Math.max(size.x, size.y, size.z);
                    const scaleFactor = 3 / maxDim; // Scale to fit in a 3-unit space
                    object.scale.set(scaleFactor, scaleFactor, scaleFactor);

                    // Center the model
                    box.setFromObject(object);
                    const center = box.getCenter(new THREE.Vector3());
                    object.position.sub(center);

                    // Apply a nice material
                    object.traverse((child) => {
                        if (child.isMesh) {
                            child.material = new THREE.MeshNormalMaterial();
                        }
                    });

                    pivot.add(object);
                },
                undefined, // Progress callback
                function (error) {
                    console.warn("Model failed to load, keeping placeholder.", error);
                }
            );

            // Setup Chart.js
            const ctx = clone.querySelector('.device-chart').getContext('2d');
            const chart = new Chart(ctx, {
                type: 'line',
                data: {
                    labels: Array(50).fill(''),
                    datasets: [
                        { label: 'Roll', data: Array(50).fill(0), borderColor: '#ef4444', borderWidth: 1, pointRadius: 0 }, // Red
                        { label: 'Pitch', data: Array(50).fill(0), borderColor: '#22c55e', borderWidth: 1, pointRadius: 0 }, // Green
                    ]
                },
                options: { 
                    animation: false, 
                    responsive: true, 
                    maintainAspectRatio: false, 
                    scales: { 
                        y: { display: true, grid: { color: '#4b5563' } }, // Show Y axis grid
                        x: { display: false } 
                    },
                    plugins: { legend: { display: false } }
                }
            });

            // Bind Settings Buttons
            clone.querySelector('.settings-btn').addEventListener('click', () => {
                card.querySelector('.settings-modal').classList.remove('hidden');
                card.querySelector('.settings-modal').classList.add('flex');
            });
            
            clone.querySelector('.close-settings').addEventListener('click', () => {
                card.querySelector('.settings-modal').classList.add('hidden');
                card.querySelector('.settings-modal').classList.remove('flex');
            });

            clone.querySelector('.save-settings').addEventListener('click', () => {
                const rate = card.querySelector('.rate-select').value;
                const bw = card.querySelector('.bw-select').value;
                applySettings(device.id, rate, bw);
            });

            clone.querySelector('.calibrate-btn').addEventListener('click', () => calibrateSensor(device.id));

            container.appendChild(clone);

            // Return 'pivot' as the mesh to rotate in handleData
            return { scene, camera, renderer, mesh: pivot, chart, card };
        }

        // --- 3. DATA PARSING & VISUALIZATION LOOP ---
        function handleData(event, deviceId) {
            const value = event.target.value;
            const context = devices.get(deviceId);
            if (!context) return;

            // Header Check (0x55 0x61)
            if (value.getUint8(0) === 0x55 && value.getUint8(1) === 0x61) {
                
                const getShort = (idx) => {
                    let v = (value.getUint8(idx+1) << 8) | value.getUint8(idx);
                    return v >= 32768 ? v - 65536 : v;
                };

                const ax = getShort(2) / 32768 * 16;
                const ay = getShort(4) / 32768 * 16;
                const az = getShort(6) / 32768 * 16;
                
                const angX = getShort(12) / 32768 * 180; // Roll
                const angY = getShort(14) / 32768 * 180; // Pitch
                const angZ = getShort(16) / 32768 * 180; // Yaw

                // Update UI Text
                const ui = context.ui;
                ui.card.querySelector('.val-ang-x').innerText = angX.toFixed(2) + "°";
                ui.card.querySelector('.val-ang-y').innerText = angY.toFixed(2) + "°";
                ui.card.querySelector('.val-ang-z').innerText = angZ.toFixed(2) + "°";

                // Update 3D Model
                if (ui.mesh) {
                    ui.mesh.rotation.x = angX * (Math.PI / 180);
                    ui.mesh.rotation.z = angY * (Math.PI / 180); 
                    ui.mesh.rotation.y = -angZ * (Math.PI / 180);
                    ui.renderer.render(ui.scene, ui.camera);
                }

                // Update Chart (Rolling Window)
                const chart = ui.chart;
                chart.data.datasets[0].data.push(angX);
                chart.data.datasets[1].data.push(angY);
                chart.data.datasets[0].data.shift();
                chart.data.datasets[1].data.shift();
                chart.update();

                // Recording Logic
                if (isRecording) {
                    const timestamp = Date.now() - recordingStartTime;
                    context.dataLog.push({ timestamp, ax, ay, az, angX, angY, angZ });
                }
            }
        }

        // --- 4. COMMANDS (SETTINGS & CALIBRATION) ---
        async function sendCommand(deviceId, commandBytes) {
            const context = devices.get(deviceId);
            if (!context) return;
            try {
                // Unlock command (required by protocol)
                await context.writeChar.writeValue(new Uint8Array([0xFF, 0xAA, 0x69, 0x88, 0xB5])); 
                // Actual command
                await new Promise(r => setTimeout(r, 20)); // Small delay
                await context.writeChar.writeValue(new Uint8Array(commandBytes));
                // Save command
                await new Promise(r => setTimeout(r, 20));
                await context.writeChar.writeValue(new Uint8Array([0xFF, 0xAA, 0x00, 0x00, 0x00])); 
            } catch (e) {
                console.error("Command failed", e);
            }
        }

        function applySettings(deviceId, rateHex, bwHex) {
            // Rate Command: FF AA 03 [Rate] 00
            sendCommand(deviceId, [0xFF, 0xAA, 0x03, parseInt(rateHex, 16), 0x00]);
            // Bandwidth Command: FF AA 1F [BW] 00
            setTimeout(() => {
                sendCommand(deviceId, [0xFF, 0xAA, 0x1F, parseInt(bwHex, 16), 0x00]);
            }, 100);
        }

        function calibrateSensor(deviceId) {
            if(confirm("Keep sensor flat and still. Start Acceleration Calibration?")) {
                // Accel Calib Command: FF AA 01 01 00
                sendCommand(deviceId, [0xFF, 0xAA, 0x01, 0x01, 0x00]);
            }
        }

        // --- 5. RECORDING & EXPORT ---
        document.getElementById('recordBtn').addEventListener('click', () => {
            isRecording = !isRecording;
            const btn = document.getElementById('recordBtn');
            if (isRecording) {
                recordingStartTime = Date.now();
                btn.innerText = "Stop Recording";
                btn.classList.replace('bg-red-600', 'bg-gray-600');
                // Clear previous logs
                devices.forEach(d => d.dataLog = []);
            } else {
                btn.innerText = "Start Recording";
                btn.classList.replace('bg-gray-600', 'bg-red-600');
                document.getElementById('exportBtn').classList.remove('hidden');
            }
        });

        document.getElementById('exportBtn').addEventListener('click', () => {
            // Export all connected devices
            devices.forEach((context, id) => {
                let csv = "Timestamp,AccX,AccY,AccZ,AngleX,AngleY,AngleZ\n";
                context.dataLog.forEach(row => {
                    csv += `${row.timestamp},${row.ax},${row.ay},${row.az},${row.angX},${row.angY},${row.angZ}\n`;
                });
                
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = window.URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = `Sensor_${id}_Data.csv`;
                a.click();
            });
        });

    </script>
</body>
</html>
